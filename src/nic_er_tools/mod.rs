mod process_options;

pub use process_options::ProcessOptions;
use process_options::process_options;

// =====================================================================
// The code here implements a custom iterator processor based
// *heavily* on the `itertools::process_results()` idea.
//
// The idea is that we have an iterator over `Option<i32>` types (generated by
// the `.zip` call above) that we would like to just `.sum()` up. The
// `process_results()` method from the `itertools` crate gives you the
// ability to take an iterator over results, and essentially map a custom
// function over an iterator over the success values. We wanted to essentially
// do the same thing here, but with an iterator over `Option` types.
// =====================================================================

// The trait that provides the signature for `process_options()`.
// `F` is the function type, which takes the iterator over the
// values of type `T` (`ProcessOptions`) and returns the desired result of
// type `R`. We need to implement this on some type that implements an
// an iterator over values of type `Option<T>`.
pub trait NicErTools {
    fn process_options<F, T, R>(self, processor: F) -> Option<R>
    where
        Self: Iterator<Item = Option<T>>,
        F: FnOnce(ProcessOptions<'_, Self>) -> R;
}

// Implement `NicErTools` for any iterator.
impl<I> NicErTools for I
where
    I: Iterator,
{
    fn process_options<F, T, R>(self, processor: F) -> Option<R>
    where
        Self: Iterator<Item = Option<T>>,
        F: FnOnce(ProcessOptions<'_, Self>) -> R,
    {
        process_options(self, processor)
    }
}
