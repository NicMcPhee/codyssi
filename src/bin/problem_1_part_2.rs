use std::iter::once;

fn main() {
    let input = include_str!("../inputs/problem_1.txt");
    let compass_offset = compute_offset(input).unwrap();
    println!("The final offset was {compass_offset}.");
}

fn compute_offset(input: &str) -> Option<i32> {
    let mut lines = input.trim().lines();
    let signs_string = lines.next_back()?;

    let values = lines.map(|s| s.parse::<i32>().ok());

    // The `once()` call inserts a `+` at the start of the iterator over the sign symbols.
    // This allows us to not treat the first number in `lines` specially; we just
    // treat it as a positive value and add it in.
    let sign_chars = once('+').chain(signs_string.chars().rev());
    let signs = sign_chars.map(|c| match c {
        '+' => Some(1),
        '-' => Some(-1),
        _ => None,
    });

    signs
        .into_iter()
        .zip(values)
        .map(|(sign, value)| Some(sign? * value?))
        // Add up all the `Some` values in this iterator, returning a `None` if
        // any of the values in the iterator is `None`.`
        .process_options(|i| i.sum())
}

// =====================================================================
// The code from here down implements a custom iterator processor based
// *heavily* on the `itertools::process_results()` idea.
//
// The idea is that we have an iterator over `Option<i32>` types (generated by
// the `.zip` call above) that we would like to just `.sum()` up. The
// `process_results()` method from the `itertools` crate gives you the
// ability to take an iterator over results, and essentially map a custom
// function over an iterator over the success values. We wanted to essentially
// do the same thing here, but with an iterator over `Option` types.
// =====================================================================

// The trait that provides the signature for `process_options()`.
// `F` is the function type, which takes the iterator over the
// values of type `T` (`ProcessOptions`) and returns the desired result of
// type `R`. We need to implement this on some type that implements an
// an iterator over values of type `Option<T>`.
trait NicErTools {
    fn process_options<F, T, R>(self, processor: F) -> Option<R>
    where
        Self: Iterator<Item = Option<T>>,
        F: FnOnce(ProcessOptions<'_, Self>) -> R;
}

// Implement `NicErTools` for any iterator.
impl<I> NicErTools for I
where
    I: Iterator,
{
    fn process_options<F, T, R>(self, processor: F) -> Option<R>
    where
        Self: Iterator<Item = Option<T>>,
        F: FnOnce(ProcessOptions<'_, Self>) -> R,
    {
        // This keeps track of whether any of the values in `Self`
        // had the value `None`.
        let mut found_none: bool = false;

        let process_options = ProcessOptions {
            internal_iterator: self,
            found_none: &mut found_none,
        };

        let result = processor(process_options);

        // If we ever encountered a `None` value, we want
        // to return `None`; otherwise we wrap `result` in
        // a `Some` variant.
        if found_none { None } else { Some(result) }
    }
}

// To process an iterator of `Option`s we'll need to have
// the iterator that provides those `Option` values, and
// mutable access to a boolean that keeps track of whether
// we encountered a `None` value in that sequence of
// `Option`s.
struct ProcessOptions<'a, OptionIterator> {
    internal_iterator: OptionIterator,
    found_none: &'a mut bool,
}

// Implement `Iterator` for our `ProcessOptions` structure. This
// mostly just passes the work on to the `internal_iterator`, along
// with a bunch of "wrapper" logic to keep track of whether we've
// encountered a `None` value.
impl<OptionIterator, T> Iterator for ProcessOptions<'_, OptionIterator>
where
    OptionIterator: Iterator<Item = Option<T>>,
{
    type Item = T;

    fn next(&mut self) -> Option<Self::Item> {
        if *self.found_none {
            // If we've ever encountered a `None` value, we should
            // always return `None` for subsequent requests.
            None
        } else {
            // Get the next value from the internal iterator.
            let n = self.internal_iterator.next();
            match n {
                // We've reached the end of the `internal_iterator`, so
                // we return `None` to indicate that the iterator is
                // finished.
                None => None,
                // The `internal_iterator` returned a `None` _value_
                // (i.e., wrapped in a `Some`), which means that we
                // want to record this in `found_none` and return
                // `None`.
                Some(None) => {
                    *self.found_none = true;
                    None
                }
                // The `internal_iterator` returned a `Some` value
                // so we want to pass that along.
                Some(Some(v)) => Some(v),
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::NicErTools;
    use super::compute_offset;

    #[test]
    fn test_input() {
        let input = include_str!("../inputs/problem_1_test.txt");
        let compass_offset = compute_offset(input).unwrap();
        assert_eq!(compass_offset, 23);
    }

    #[test]
    fn sum_of_doubled_options() {
        let result: i32 = [Some(1), Some(5), Some(10)]
            .into_iter()
            .process_options(|inner| inner.map(|x| x * 2).sum())
            .unwrap();
        assert_eq!(result, 32);
    }

    #[test]
    fn array_has_none() {
        let result: Option<i32> = [Some(1), Some(5), None, Some(10)]
            .into_iter()
            .process_options(|inner| inner.map(|x| x * 2).sum());
        assert_eq!(result, None);
    }
}
